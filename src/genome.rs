use crdts::{list, CmRDT, List};
use rand::prelude::*;
use std::fmt;

/// Actor id
pub type Actor = usize;

/// a number representing a simple 'gene'
pub type Gene = u8;

/// CRDT List
type ListOfGenes = List<Gene, Actor>;

/// The object representing a genome
/// to be stored in server state
pub struct Genome {
    genes: ListOfGenes,
}

impl Genome {
    /// return a new, empty Genome object
    fn new() -> Self {
        Genome {
            genes: ListOfGenes::new(),
        }
    }

    /// generate a random change to the genome
    /// returns a CRDT Op that can be circulated to other actors
    pub fn generate(&mut self, actor: Actor) -> list::Op<Gene, Actor> {
        // TODO: make min_length configurable
        const MIN_LEN: usize = 10;

        let mut rng = thread_rng();

        // generate a boolean to choose insert or delete
        // force insert if the list is below a minimum length
        let op = if self.genes.len() < MIN_LEN || rng.gen() {
            //insert

            // we include =self.genes.len() to append
            let index = rng.gen_range(0..=self.genes.len());

            // generate a random item
            let value: u8 = rng.gen();
            self.genes.insert_index(index, value, actor)
        } else {
            // delete

            let index = rng.gen_range(0..self.genes.len());

            // unwrap should be harmless, because we just generated a valid index
            self.genes.delete_index(index, actor).unwrap()
        };

        self.genes.apply(op.clone());
        tracing::debug!("after Genome::generate: {}", self);
        op
    }

    /// apply an Op, probably one generated by a remote actor
    pub fn apply(&mut self, op: list::Op<Gene, Actor>) {
        self.genes.apply(op);
        tracing::debug!("after Genome::apply: {}", self);
    }

    #[cfg(test)]
    fn is_equal(&self, rhs: &Self) -> bool {
        use std::cmp::Ordering;
        self.genes.iter().cmp(rhs.genes.iter()) == Ordering::Equal
    }
}

impl Default for Genome {
    /// return a new, empty Genome object
    fn default() -> Self {
        Genome::new()
    }
}

impl fmt::Display for Genome {
    /// display the genome as a string of hexadecimal digits
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        let mut out = String::new();
        for gene in self.genes.iter() {
            let s = format!("{:02x}", gene);
            out.push_str(&s);
        }
        write!(f, "{}", out)
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn can_create_empty_genome() {
        let g = Genome::new();
        assert!(g.genes.is_empty());
        let v = g.genes.read::<Vec<&u8>>();
        assert!(v.is_empty());
    }

    #[test]
    fn can_append() {
        let mut g = Genome::new();
        assert!(g.genes.is_empty());

        let a: Actor = 111;

        let _op = g.generate(a);

        assert!(!g.genes.is_empty());
    }

    #[test]
    fn append_preserves_order() {
        let mut g1 = Genome::new();
        let mut g2 = Genome::new();

        const A1: Actor = 111;
        const A2: Actor = 222;

        let mut g1ops = vec![g1.generate(A1)];
        g1ops.push(g1.generate(A1));
        g1ops.push(g1.generate(A1));

        let mut g2ops = vec![g2.generate(A2)];
        g2ops.push(g2.generate(A2));
        g2ops.push(g2.generate(A2));

        for op in &g2ops {
            g1.apply(op.clone());
        }

        for op in &g1ops {
            g2.apply(op.clone());
        }

        let g1_genes = g1.genes.read::<Vec<&u8>>();
        println!("g1 genes = {:?}", g1_genes);

        let g2_genes = g2.genes.read::<Vec<&u8>>();
        println!("g2 genes = {:?}", g2_genes);

        assert!(g1.is_equal(&g2));
    }

    #[test]
    fn display_looks_right() {
        const ACTOR: Actor = 42;
        let mut g = Genome::new();
        assert_eq!(format!("{}", g), "");
        g.apply(g.genes.append(0, ACTOR));
        assert_eq!(format!("{}", g), "00");
        g.apply(g.genes.append(1, ACTOR));
        assert_eq!(format!("{}", g), "0001");
        g.apply(g.genes.append(255, ACTOR));
        assert_eq!(format!("{}", g), "0001ff");
    }
}
